<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zabbixå±¥æ­´ãƒ‡ãƒ¼ã‚¿ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 10px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            overflow: hidden;
        }

        header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        header h1 {
            font-size: 2em;
            margin-bottom: 10px;
        }

        header p {
            opacity: 0.9;
        }

        .content {
            padding: 30px;
        }

        .section {
            margin-bottom: 30px;
            padding: 20px;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            background: #f9f9f9;
        }

        .section h2 {
            color: #667eea;
            margin-bottom: 20px;
            font-size: 1.5em;
            border-bottom: 2px solid #667eea;
            padding-bottom: 10px;
        }

        .form-group {
            margin-bottom: 15px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: #333;
        }

        input[type="text"],
        input[type="password"],
        input[type="datetime-local"],
        select {
            width: 100%;
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 5px;
            font-size: 14px;
            transition: border-color 0.3s;
        }

        input[type="text"]:focus,
        input[type="password"]:focus,
        input[type="datetime-local"]:focus,
        select:focus {
            outline: none;
            border-color: #667eea;
        }

        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 5px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            margin-right: 10px;
            margin-top: 10px;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        button:active {
            transform: translateY(0);
        }

        button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .status {
            padding: 10px;
            border-radius: 5px;
            margin-top: 10px;
            display: none;
        }

        .status.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .status.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .status.info {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }

        .hidden {
            display: none;
        }

        .data-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
            overflow-x: auto;
            display: block;
        }

        .data-table table {
            width: 100%;
            min-width: 600px;
        }

        .data-table th,
        .data-table td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }

        .data-table th {
            background: #667eea;
            color: white;
            font-weight: 600;
            position: sticky;
            top: 0;
        }

        .data-table tr:hover {
            background: #f5f5f5;
        }

        .loading {
            text-align: center;
            padding: 20px;
            color: #667eea;
            font-size: 1.2em;
        }

        .loading::after {
            content: '...';
            animation: dots 1.5s steps(4, end) infinite;
        }

        @keyframes dots {
            0%, 20% { content: '.'; }
            40% { content: '..'; }
            60%, 100% { content: '...'; }
        }

        select[multiple] {
            height: 150px;
        }

        .info-text {
            font-size: 0.9em;
            color: #666;
            margin-top: 5px;
            font-style: italic;
        }

        .button-group {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        @media (max-width: 768px) {
            .content {
                padding: 15px;
            }

            header h1 {
                font-size: 1.5em;
            }

            .button-group {
                flex-direction: column;
            }

            button {
                width: 100%;
                margin-right: 0;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>ğŸ“Š Zabbixå±¥æ­´ãƒ‡ãƒ¼ã‚¿ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ</h1>
            <p>Zabbix APIã‚’ä½¿ç”¨ã—ã¦ãƒ’ã‚¹ãƒˆãƒªãƒ¼ãƒ‡ãƒ¼ã‚¿ã‚’ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ</p>
        </header>

        <div class="content">
            <!-- Connection Section -->
            <div class="section">
                <h2>1. Zabbixæ¥ç¶šè¨­å®š</h2>
                <div class="form-group">
                    <label for="zabbixUrl">Zabbix URL:</label>
                    <input type="text" id="zabbixUrl" placeholder="https://zabbix-server.example.com">
                    <div class="info-text">ä¾‹: https://zabbix.example.comï¼ˆ/api_jsonrpc.phpã¯è‡ªå‹•è¿½åŠ ã•ã‚Œã¾ã™ï¼‰</div>
                </div>
                <div class="form-group">
                    <label for="username">ãƒ¦ãƒ¼ã‚¶ãƒ¼å:</label>
                    <input type="text" id="username" placeholder="ç®¡ç†è€…">
                </div>
                <div class="form-group">
                    <label for="password">ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰:</label>
                    <input type="password" id="password" placeholder="ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰">
                </div>
                <button id="connectBtn" onclick="connectToZabbix()">æ¥ç¶š</button>
                <button id="disconnectBtn" onclick="disconnect()" class="hidden">åˆ‡æ–­</button>
                <div id="connectionStatus" class="status"></div>
            </div>

            <!-- Host Selection Section -->
            <div id="hostSection" class="section hidden">
                <h2>2. ãƒ›ã‚¹ãƒˆé¸æŠ</h2>
                <div class="form-group">
                    <label for="exportMode">ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆãƒ¢ãƒ¼ãƒ‰:</label>
                    <select id="exportMode" onchange="changeExportMode()">
                        <option value="item">å€‹åˆ¥ã‚¢ã‚¤ãƒ†ãƒ é¸æŠ</option>
                        <option value="host">ãƒ›ã‚¹ãƒˆå…¨ä½“ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ</option>
                    </select>
                    <div class="info-text">å€‹åˆ¥: ç‰¹å®šã®ã‚¢ã‚¤ãƒ†ãƒ ã‚’é¸æŠ / ãƒ›ã‚¹ãƒˆå…¨ä½“: ã™ã¹ã¦ã®ã‚¢ã‚¤ãƒ†ãƒ ã‚’ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ</div>
                </div>
                <div class="form-group">
                    <label for="hostSearchInput">ãƒ›ã‚¹ãƒˆæ¤œç´¢:</label>
                    <div style="position: relative;">
                        <input type="text" 
                               id="hostSearchInput" 
                               placeholder="ãƒ›ã‚¹ãƒˆåã‚’å…¥åŠ›ã—ã¦æ¤œç´¢... (2æ–‡å­—ä»¥ä¸Š)"
                               autocomplete="off"
                               style="width: 100%; padding: 8px; box-sizing: border-box;">
                        <div id="hostSearchDropdown" style="display: none; position: absolute; top: 100%; left: 0; right: 0; background: white; border: 1px solid #ccc; border-radius: 4px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); max-height: 300px; overflow-y: auto; z-index: 1000; margin-top: 2px;">
                            <!-- ã‚«ã‚¹ã‚¿ãƒ ãƒ‰ãƒ­ãƒƒãƒ—ãƒ€ã‚¦ãƒ³ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ -->
                        </div>
                    </div>
                    <div id="selectedHostsDisplay" style="margin-top: 10px; padding: 10px; background: #f5f5f5; border-radius: 4px; min-height: 40px;">
                        <small style="color: #666;">é¸æŠã•ã‚ŒãŸãƒ›ã‚¹ãƒˆ: ãªã—</small>
                    </div>
                    <div class="info-text" id="hostSelectInfo">æ¤œç´¢ã—ã¦ãƒ›ã‚¹ãƒˆã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚è¤‡æ•°é¸æŠã™ã‚‹å ´åˆã¯å†åº¦æ¤œç´¢ã—ã¦é¸æŠã—ã¦ãã ã•ã„ã€‚</div>
                </div>
                <div id="hostStatus" class="status"></div>
            </div>

            <!-- Item Selection Section -->
            <div id="itemSection" class="section hidden">
                <h2>3. ã‚¢ã‚¤ãƒ†ãƒ é¸æŠ</h2>
                <div class="form-group">
                    <label for="itemSelect">ã‚¢ã‚¤ãƒ†ãƒ  (è¤‡æ•°é¸æŠå¯):</label>
                    <select id="itemSelect" multiple>
                        <option value="">ã‚¢ã‚¤ãƒ†ãƒ ã‚’é¸æŠã—ã¦ãã ã•ã„</option>
                    </select>
                    <div class="info-text">Ctrlã‚­ãƒ¼(ã¾ãŸã¯Cmd)ã‚’æŠ¼ã—ãªãŒã‚‰ã‚¯ãƒªãƒƒã‚¯ã§è¤‡æ•°é¸æŠ</div>
                </div>
                <div id="itemStatus" class="status"></div>
            </div>

            <!-- Time Range Section -->
            <div id="timeSection" class="section hidden">
                <h2>4. æ™‚é–“ç¯„å›²é¸æŠ</h2>
                <div class="form-group">
                    <label for="timeFrom">é–‹å§‹æ™‚åˆ»:</label>
                    <input type="datetime-local" id="timeFrom">
                </div>
                <div class="form-group">
                    <label for="timeTill">çµ‚äº†æ™‚åˆ»:</label>
                    <input type="datetime-local" id="timeTill">
                </div>
                <div class="button-group">
                    <button id="getHistoryBtn" onclick="getHistory()">å±¥æ­´ãƒ‡ãƒ¼ã‚¿å–å¾—</button>
                    <button id="getHostHistoryBtn" onclick="getHostHistory()" class="hidden">ãƒ›ã‚¹ãƒˆå…¨ä½“ã®å±¥æ­´ãƒ‡ãƒ¼ã‚¿å–å¾—</button>
                </div>
                <div id="timeStatus" class="status"></div>
            </div>

            <!-- Results Section -->
            <div id="resultsSection" class="section hidden">
                <h2>5. çµæœ</h2>
                <div class="button-group">
                    <button onclick="exportToCSV()">CSVã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ</button>
                    <button onclick="exportToJSON()">JSONã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ</button>
                </div>
                <div id="resultsStatus" class="status"></div>
                <div id="resultsTable" class="data-table"></div>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let authToken = null;
        let historyData = [];
        let currentHosts = [];
        let currentItems = [];
        let apiRequestCounter = 0;
        let exportMode = 'item'; // 'item' ã¾ãŸã¯ 'host'

        // Initialize datetime inputs with default values (last 24 hours)
        window.onload = function() {
            const now = new Date();
            const yesterday = new Date(now.getTime() - 24 * 60 * 60 * 1000);
            
            document.getElementById('timeTill').value = formatDateTimeLocal(now);
            document.getElementById('timeFrom').value = formatDateTimeLocal(yesterday);
        };

        function formatDateTimeLocal(date) {
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            const hours = String(date.getHours()).padStart(2, '0');
            const minutes = String(date.getMinutes()).padStart(2, '0');
            return `${year}-${month}-${day}T${hours}:${minutes}`;
        }

        function showStatus(elementId, message, type) {
            const statusElement = document.getElementById(elementId);
            // æ”¹è¡Œã‚’<br>ã‚¿ã‚°ã«å¤‰æ›
            statusElement.innerHTML = message.replace(/\n/g, '<br>');
            statusElement.className = `status ${type}`;
            statusElement.style.display = 'block';
        }

        function hideStatus(elementId) {
            const statusElement = document.getElementById(elementId);
            statusElement.style.display = 'none';
        }

        async function callZabbixAPI(method, params) {
            const url = document.getElementById('zabbixUrl').value;
            
            const requestBody = {
                jsonrpc: '2.0',
                method: method,
                params: params,
                id: ++apiRequestCounter
            };

            if (authToken && method !== 'user.login') {
                requestBody.auth = authToken;
            }

            try {
                const response = await fetch(url, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(requestBody)
                });

                const data = await response.json();

                if (data.error) {
                    throw new Error(data.error.data || data.error.message);
                }

                return data.result;
            } catch (error) {
                console.error('API Error:', error);
                throw error;
            }
        }

        // URLã‚’æ­£è¦åŒ–ï¼ˆ/api_jsonrpc.phpã‚’è‡ªå‹•è¿½åŠ ï¼‰
        function normalizeZabbixUrl(url) {
            if (!url) return url;
            
            // URLã‚’ãƒˆãƒªãƒ 
            url = url.trim();
            
            // æ—¢ã«/api_jsonrpc.phpãŒå«ã¾ã‚Œã¦ã„ã‚‹å ´åˆã¯ãã®ã¾ã¾è¿”ã™
            if (url.includes('/api_jsonrpc.php')) {
                return url;
            }
            
            // æœ«å°¾ã®ã‚¹ãƒ©ãƒƒã‚·ãƒ¥ã‚’å‰Šé™¤
            url = url.replace(/\/+$/, '');
            
            // /api_jsonrpc.phpã‚’è¿½åŠ 
            return url + '/api_jsonrpc.php';
        }

        async function connectToZabbix() {
            let url = document.getElementById('zabbixUrl').value;
            const username = document.getElementById('username').value;
            const password = document.getElementById('password').value;

            if (!url || !username || !password) {
                showStatus('connectionStatus', 'ã™ã¹ã¦ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„', 'error');
                return;
            }

            // URLã‚’æ­£è¦åŒ–ï¼ˆ/api_jsonrpc.phpã‚’è‡ªå‹•è¿½åŠ ï¼‰
            url = normalizeZabbixUrl(url);
            // æ­£è¦åŒ–ã•ã‚ŒãŸURLã‚’å…¥åŠ›ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã«åæ˜ 
            document.getElementById('zabbixUrl').value = url;

            showStatus('connectionStatus', 'æ¥ç¶šä¸­...', 'info');

            try {
                authToken = await callZabbixAPI('user.login', {
                    username: username,
                    password: password
                });

                showStatus('connectionStatus', 'æ¥ç¶šæˆåŠŸï¼', 'success');
                
                // Update UI
                document.getElementById('connectBtn').classList.add('hidden');
                document.getElementById('disconnectBtn').classList.remove('hidden');
                document.getElementById('zabbixUrl').disabled = true;
                document.getElementById('username').disabled = true;
                document.getElementById('password').disabled = true;

                // Show next sections
                document.getElementById('hostSection').classList.remove('hidden');
                
                // ãƒ›ã‚¹ãƒˆã¯æ¤œç´¢ãƒ™ãƒ¼ã‚¹ãªã®ã§ã€ã“ã“ã§ã¯ãƒ­ãƒ¼ãƒ‰ã—ãªã„
                showStatus('hostStatus', 'ãƒ›ã‚¹ãƒˆæ¤œç´¢ã®æº–å‚™ãŒã§ãã¾ã—ãŸã€‚ãƒ›ã‚¹ãƒˆåã‚’å…¥åŠ›ã—ã¦æ¤œç´¢ã—ã¦ãã ã•ã„ã€‚', 'success');

            } catch (error) {
                let errorMessage = `æ¥ç¶šã‚¨ãƒ©ãƒ¼: ${error.message}`;
                
                // ã‚ˆã‚Šè©³ã—ã„ã‚¨ãƒ©ãƒ¼æƒ…å ±ã‚’æä¾›
                if (error.message.includes('Incorrect user name or password')) {
                    errorMessage = `èªè¨¼ã‚¨ãƒ©ãƒ¼: ãƒ¦ãƒ¼ã‚¶ãƒ¼åã¾ãŸã¯ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãŒé–“é•ã£ã¦ã„ã¾ã™ã€‚\n\nç¢ºèªäº‹é …ï¼š\nâ€¢ ãƒ¦ãƒ¼ã‚¶ãƒ¼åã¨ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãŒæ­£ã—ã„ã‹\nâ€¢ Zabbix Webã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã§åŒã˜èªè¨¼æƒ…å ±ã§ãƒ­ã‚°ã‚¤ãƒ³ã§ãã‚‹ã‹\nâ€¢ ã‚¢ã‚«ã‚¦ãƒ³ãƒˆãŒãƒ­ãƒƒã‚¯ã•ã‚Œã¦ã„ãªã„ã‹`;
                } else if (error.message.includes('temporarily blocked')) {
                    errorMessage = `èªè¨¼ã‚¨ãƒ©ãƒ¼: ã‚¢ã‚«ã‚¦ãƒ³ãƒˆãŒä¸€æ™‚çš„ã«ãƒ–ãƒ­ãƒƒã‚¯ã•ã‚Œã¦ã„ã¾ã™ã€‚\n\nå¯¾å‡¦æ–¹æ³•ï¼š\nâ€¢ ã—ã°ã‚‰ãå¾…ã£ã¦ã‹ã‚‰å†è©¦è¡Œã—ã¦ãã ã•ã„\nâ€¢ Zabbixç®¡ç†è€…ã«é€£çµ¡ã—ã¦ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã®ãƒ­ãƒƒã‚¯ã‚’è§£é™¤ã—ã¦ã‚‚ã‚‰ã£ã¦ãã ã•ã„`;
                } else if (error.message.includes('Connection') || error.message.includes('Failed to fetch')) {
                    errorMessage = `æ¥ç¶šã‚¨ãƒ©ãƒ¼: Zabbixã‚µãƒ¼ãƒãƒ¼ã«æ¥ç¶šã§ãã¾ã›ã‚“ã€‚\n\nç¢ºèªäº‹é …ï¼š\nâ€¢ URLãŒæ­£ã—ã„ã‹ï¼ˆä¾‹: https://your-serverï¼‰\nâ€¢ Zabbixã‚µãƒ¼ãƒãƒ¼ãŒèµ·å‹•ã—ã¦ã„ã‚‹ã‹\nâ€¢ ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯æ¥ç¶šãŒæ­£å¸¸ã‹\nâ€¢ CORSãŒæœ‰åŠ¹ã«ãªã£ã¦ã„ã‚‹ã‹`;
                }
                
                showStatus('connectionStatus', errorMessage, 'error');
                authToken = null;
            }
        }

        function disconnect() {
            authToken = null;
            historyData = [];
            currentHosts = [];
            currentItems = [];
            selectedHosts = [];  // é¸æŠæ¸ˆã¿ãƒ›ã‚¹ãƒˆã‚‚ã‚¯ãƒªã‚¢

            // Reset UI
            document.getElementById('connectBtn').classList.remove('hidden');
            document.getElementById('disconnectBtn').classList.add('hidden');
            document.getElementById('zabbixUrl').disabled = false;
            document.getElementById('username').disabled = false;
            document.getElementById('password').disabled = false;
            
            // ãƒ›ã‚¹ãƒˆæ¤œç´¢ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã¨datalistã‚’ã‚¯ãƒªã‚¢
            document.getElementById('hostSearchInput').value = '';
            document.getElementById('hostSearchDatalist').innerHTML = '';
            updateSelectedHostsDisplay();

            // Hide sections
            document.getElementById('hostSection').classList.add('hidden');
            document.getElementById('itemSection').classList.add('hidden');
            document.getElementById('timeSection').classList.add('hidden');
            document.getElementById('resultsSection').classList.add('hidden');

            // Clear selections
            document.getElementById('hostSelect').innerHTML = '<option value="">ãƒ›ã‚¹ãƒˆã‚’é¸æŠã—ã¦ãã ã•ã„</option>';
            document.getElementById('itemSelect').innerHTML = '<option value="">ã‚¢ã‚¤ãƒ†ãƒ ã‚’é¸æŠã—ã¦ãã ã•ã„</option>';
            document.getElementById('resultsTable').innerHTML = '';

            showStatus('connectionStatus', 'åˆ‡æ–­ã—ã¾ã—ãŸ', 'info');
        }

        // é¸æŠæ¸ˆã¿ãƒ›ã‚¹ãƒˆã‚’ç®¡ç†ã™ã‚‹ãŸã‚ã®å¤‰æ•°
        let selectedHosts = [];

        // ãƒ›ã‚¹ãƒˆæ¤œç´¢é–¢æ•°ï¼ˆ2æ–‡å­—ä»¥ä¸Šã§æ¤œç´¢ã€æœ€å¤§100ä»¶ã¾ã§ï¼‰
        async function searchHosts(query) {
            if (!query || query.trim().length < 2) {
                return [];
            }
            
            try {
                const hosts = await callZabbixAPI('host.get', {
                    output: ['hostid', 'host', 'name'],
                    search: {
                        name: query.trim()
                    },
                    sortfield: 'name',
                    sortorder: 'ASC',
                    limit: 100
                });
                
                return hosts;
            } catch (error) {
                console.error('Host search error:', error);
                showStatus('hostStatus', `ãƒ›ã‚¹ãƒˆæ¤œç´¢ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
                return [];
            }
        }

        // ã‚«ã‚¹ã‚¿ãƒ ãƒ‰ãƒ­ãƒƒãƒ—ãƒ€ã‚¦ãƒ³ã‚’æ›´æ–°ã™ã‚‹é–¢æ•°
        let selectedDropdownIndex = -1;
        
        function updateHostDropdown(hosts) {
            currentHosts = hosts;
            selectedDropdownIndex = -1;
            const dropdown = document.getElementById('hostSearchDropdown');
            
            if (hosts.length === 0) {
                dropdown.innerHTML = '<div style="padding: 10px; color: #999; text-align: center;">çµæœãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“</div>';
                dropdown.style.display = 'block';
                return;
            }
            
            let html = `<div style="padding: 8px; background: #f8f9fa; border-bottom: 1px solid #dee2e6; font-size: 0.9em; color: #666;">ğŸ“‹ ${hosts.length}ä»¶ã®çµæœ</div>`;
            
            hosts.forEach((host, index) => {
                const displayName = host.name || host.host;
                const technicalName = host.host;
                html += `
                    <div class="host-search-item" data-index="${index}" data-hostid="${host.hostid}" data-hostname="${technicalName}" data-displayname="${displayName}"
                         style="padding: 10px; cursor: pointer; border-bottom: 1px solid #eee;">
                        <div style="font-weight: 500; color: #333;">${escapeHtml(displayName)}</div>
                        <div style="font-size: 0.85em; color: #666; margin-top: 2px;">${escapeHtml(technicalName)}</div>
                    </div>
                `;
            });
            
            dropdown.innerHTML = html;
            dropdown.style.display = 'block';
            
            // ã‚¯ãƒªãƒƒã‚¯ã‚¤ãƒ™ãƒ³ãƒˆã‚’è¿½åŠ 
            dropdown.querySelectorAll('.host-search-item').forEach(item => {
                item.addEventListener('click', function() {
                    const displayName = this.getAttribute('data-displayname');
                    selectHostFromDropdown(displayName);
                });
                
                item.addEventListener('mouseenter', function() {
                    // ä»–ã®ãƒ›ãƒãƒ¼çŠ¶æ…‹ã‚’è§£é™¤
                    dropdown.querySelectorAll('.host-search-item').forEach(i => {
                        i.style.background = '';
                    });
                    this.style.background = '#e3f2fd';
                    selectedDropdownIndex = parseInt(this.getAttribute('data-index'));
                });
            });
        }
        
        function hideHostDropdown() {
            const dropdown = document.getElementById('hostSearchDropdown');
            dropdown.style.display = 'none';
            selectedDropdownIndex = -1;
        }
        
        function selectHostFromDropdown(displayName) {
            const searchInput = document.getElementById('hostSearchInput');
            searchInput.value = displayName;
            hideHostDropdown();
            addSelectedHost(displayName);
        }
        
        function highlightDropdownItem(index) {
            const dropdown = document.getElementById('hostSearchDropdown');
            const items = dropdown.querySelectorAll('.host-search-item');
            
            items.forEach((item, i) => {
                if (i === index) {
                    item.style.background = '#e3f2fd';
                    item.scrollIntoView({ block: 'nearest' });
                } else {
                    item.style.background = '';
                }
            });
        }

        // ãƒ›ã‚¹ãƒˆã‚’é¸æŠãƒªã‚¹ãƒˆã«è¿½åŠ ã™ã‚‹é–¢æ•°
        function addSelectedHost(hostName) {
            // ã‚«ã‚¹ã‚¿ãƒ ãƒ‰ãƒ­ãƒƒãƒ—ãƒ€ã‚¦ãƒ³ã‹ã‚‰hostidã‚’å–å¾—
            let hostId = null;
            let hostTechnicalName = null;
            
            for (let host of currentHosts) {
                if ((host.name || host.host) === hostName) {
                    hostId = host.hostid;
                    hostTechnicalName = host.host;
                    break;
                }
            }
            
            if (!hostId) {
                return false;
            }
            
            // ã™ã§ã«é¸æŠæ¸ˆã¿ã‹ãƒã‚§ãƒƒã‚¯
            if (selectedHosts.find(h => h.hostid === hostId)) {
                showStatus('hostStatus', 'ã“ã®ãƒ›ã‚¹ãƒˆã¯æ—¢ã«é¸æŠã•ã‚Œã¦ã„ã¾ã™', 'info');
                return false;
            }
            
            // ãƒ›ã‚¹ãƒˆã‚’è¿½åŠ 
            selectedHosts.push({
                hostid: hostId,
                name: hostName,
                host: hostTechnicalName
            });
            
            updateSelectedHostsDisplay();
            
            // å€‹åˆ¥ã‚¢ã‚¤ãƒ†ãƒ ãƒ¢ãƒ¼ãƒ‰ã®å ´åˆã€ã‚¢ã‚¤ãƒ†ãƒ ã‚’ãƒ­ãƒ¼ãƒ‰
            exportMode = document.getElementById('exportMode').value;
            if (exportMode === 'item' && selectedHosts.length === 1) {
                loadItems();
            }
            
            showStatus('hostStatus', `ãƒ›ã‚¹ãƒˆã€Œ${hostName}ã€ã‚’é¸æŠã—ã¾ã—ãŸ`, 'success');
            
            // å…¥åŠ›ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’ã‚¯ãƒªã‚¢
            document.getElementById('hostSearchInput').value = '';
            
            return true;
        }

        // é¸æŠæ¸ˆã¿ãƒ›ã‚¹ãƒˆã®è¡¨ç¤ºã‚’æ›´æ–°ã™ã‚‹é–¢æ•°
        function updateSelectedHostsDisplay() {
            const display = document.getElementById('selectedHostsDisplay');
            
            if (selectedHosts.length === 0) {
                display.innerHTML = '<small style="color: #666;">é¸æŠã•ã‚ŒãŸãƒ›ã‚¹ãƒˆ: ãªã—</small>';
                return;
            }
            
            let html = '<div style="margin-bottom: 5px;"><strong>é¸æŠã•ã‚ŒãŸãƒ›ã‚¹ãƒˆ:</strong></div>';
            selectedHosts.forEach((host, index) => {
                html += `
                    <div style="display: inline-flex; align-items: center; background: #007bff; color: white; padding: 3px 8px; margin: 3px; border-radius: 3px; font-size: 14px; line-height: 1.4;">
                        <span style="margin-right: 5px;">${host.name}</span>
                        <button onclick="removeSelectedHost(${index})" 
                                style="display: flex; align-items: center; justify-content: center; width: 20px; height: 20px; background: none; border: none; color: white; cursor: pointer; font-weight: bold; padding: 0; line-height: 1; font-size: 18px;">Ã—</button>
                    </div>
                `;
            });
            
            display.innerHTML = html;
        }

        // ãƒ›ã‚¹ãƒˆã‚’é¸æŠãƒªã‚¹ãƒˆã‹ã‚‰å‰Šé™¤ã™ã‚‹é–¢æ•°
        function removeSelectedHost(index) {
            const removedHost = selectedHosts[index];
            selectedHosts.splice(index, 1);
            updateSelectedHostsDisplay();
            showStatus('hostStatus', `ãƒ›ã‚¹ãƒˆã€Œ${removedHost.name}ã€ã‚’é¸æŠè§£é™¤ã—ã¾ã—ãŸ`, 'info');
            
            // ã‚¢ã‚¤ãƒ†ãƒ ãƒªã‚¹ãƒˆã‚‚ã‚¯ãƒªã‚¢
            exportMode = document.getElementById('exportMode').value;
            if (exportMode === 'item' && selectedHosts.length === 0) {
                document.getElementById('itemSelect').innerHTML = '<option value="">ã‚¢ã‚¤ãƒ†ãƒ ã‚’é¸æŠã—ã¦ãã ã•ã„</option>';
                document.getElementById('itemSection').classList.add('hidden');
            } else if (exportMode === 'item' && selectedHosts.length === 1) {
                loadItems();
            }
        }

        // ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ æ¤œç´¢ã®ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—
        let searchTimeout;
        function setupHostSearch() {
            const searchInput = document.getElementById('hostSearchInput');
            const dropdown = document.getElementById('hostSearchDropdown');
            
            searchInput.addEventListener('input', async function(e) {
                const query = e.target.value.trim();
                
                clearTimeout(searchTimeout);
                
                if (query.length < 2) {
                    hideHostDropdown();
                    return;
                }
                
                searchTimeout = setTimeout(async () => {
                    showStatus('hostStatus', 'ãƒ›ã‚¹ãƒˆã‚’æ¤œç´¢ä¸­...', 'info');
                    const hosts = await searchHosts(query);
                    updateHostDropdown(hosts);
                    
                    if (hosts.length > 0) {
                        showStatus('hostStatus', `${hosts.length}ä»¶ã®ãƒ›ã‚¹ãƒˆãŒè¦‹ã¤ã‹ã‚Šã¾ã—ãŸï¼ˆæœ€å¤§100ä»¶ã¾ã§è¡¨ç¤ºï¼‰`, 'success');
                    } else {
                        showStatus('hostStatus', 'ãƒ›ã‚¹ãƒˆãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸ', 'info');
                    }
                }, 300);
            });
            
            // ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³
            searchInput.addEventListener('keydown', function(e) {
                const dropdown = document.getElementById('hostSearchDropdown');
                if (dropdown.style.display === 'none') return;
                
                if (e.key === 'ArrowDown') {
                    e.preventDefault();
                    selectedDropdownIndex = Math.min(selectedDropdownIndex + 1, currentHosts.length - 1);
                    highlightDropdownItem(selectedDropdownIndex);
                } else if (e.key === 'ArrowUp') {
                    e.preventDefault();
                    selectedDropdownIndex = Math.max(selectedDropdownIndex - 1, 0);
                    highlightDropdownItem(selectedDropdownIndex);
                } else if (e.key === 'Enter') {
                    e.preventDefault();
                    if (selectedDropdownIndex >= 0 && selectedDropdownIndex < currentHosts.length) {
                        const host = currentHosts[selectedDropdownIndex];
                        const displayName = host.name || host.host;
                        selectHostFromDropdown(displayName);
                    }
                } else if (e.key === 'Escape') {
                    hideHostDropdown();
                }
            });
            
            // ã‚¯ãƒªãƒƒã‚¯å¤–ã§é–‰ã˜ã‚‹
            document.addEventListener('click', function(e) {
                if (!searchInput.contains(e.target) && !dropdown.contains(e.target)) {
                    hideHostDropdown();
                }
            });
        }

        // ãƒšãƒ¼ã‚¸ãƒ­ãƒ¼ãƒ‰æ™‚ã«ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—
        document.addEventListener('DOMContentLoaded', function() {
            setupHostSearch();
        });

        async function loadItems() {
            // é¸æŠã•ã‚ŒãŸãƒ›ã‚¹ãƒˆãŒãªã„å ´åˆ
            if (selectedHosts.length === 0) {
                document.getElementById('itemSection').classList.add('hidden');
                return;
            }
            
            // å€‹åˆ¥ã‚¢ã‚¤ãƒ†ãƒ ãƒ¢ãƒ¼ãƒ‰ã§è¤‡æ•°ãƒ›ã‚¹ãƒˆãŒé¸æŠã•ã‚Œã¦ã„ã‚‹å ´åˆ
            exportMode = document.getElementById('exportMode').value;
            if (exportMode === 'item' && selectedHosts.length > 1) {
                showStatus('itemStatus', 'å€‹åˆ¥ã‚¢ã‚¤ãƒ†ãƒ ãƒ¢ãƒ¼ãƒ‰ã§ã¯1ã¤ã®ãƒ›ã‚¹ãƒˆã®ã¿é¸æŠã—ã¦ãã ã•ã„', 'error');
                document.getElementById('itemSection').classList.add('hidden');
                return;
            }
            
            // æœ€åˆã®ãƒ›ã‚¹ãƒˆã®ã‚¢ã‚¤ãƒ†ãƒ ã‚’ãƒ­ãƒ¼ãƒ‰
            const hostId = selectedHosts[0].hostid;

            document.getElementById('itemSection').classList.remove('hidden');
            showStatus('itemStatus', 'ã‚¢ã‚¤ãƒ†ãƒ èª­ã¿è¾¼ã¿ä¸­...', 'info');

            try {
                currentItems = await callZabbixAPI('item.get', {
                    output: ['itemid', 'name', 'key_', 'value_type'],
                    hostids: hostId,
                    sortfield: 'name',
                    webitems: false
                });

                const itemSelect = document.getElementById('itemSelect');
                itemSelect.innerHTML = '';

                currentItems.forEach(item => {
                    const option = document.createElement('option');
                    option.value = item.itemid;
                    option.textContent = `${item.name} (${item.key_})`;
                    option.dataset.valueType = item.value_type;
                    itemSelect.appendChild(option);
                });

                showStatus('itemStatus', `${currentItems.length}å€‹ã®ã‚¢ã‚¤ãƒ†ãƒ ã‚’èª­ã¿è¾¼ã¿ã¾ã—ãŸ`, 'success');
                document.getElementById('timeSection').classList.remove('hidden');

            } catch (error) {
                showStatus('itemStatus', `ã‚¢ã‚¤ãƒ†ãƒ èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
            }
        }

        function changeExportMode() {
            exportMode = document.getElementById('exportMode').value;
            const hostSelect = document.getElementById('hostSelect');
            const hostSelectInfo = document.getElementById('hostSelectInfo');
            const itemSection = document.getElementById('itemSection');
            const timeSection = document.getElementById('timeSection');
            const getHistoryBtn = document.getElementById('getHistoryBtn');
            const getHostHistoryBtn = document.getElementById('getHostHistoryBtn');

            if (exportMode === 'host') {
                // ãƒ›ã‚¹ãƒˆå…¨ä½“ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆãƒ¢ãƒ¼ãƒ‰
                hostSelectInfo.textContent = 'è¤‡æ•°ã®ãƒ›ã‚¹ãƒˆã‚’æ¤œç´¢ã—ã¦é¸æŠã§ãã¾ã™ã€‚å„ãƒ›ã‚¹ãƒˆã®ã™ã¹ã¦ã®ã‚¢ã‚¤ãƒ†ãƒ ãŒã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã•ã‚Œã¾ã™ã€‚';
                itemSection.classList.add('hidden');
                timeSection.classList.remove('hidden');
                getHistoryBtn.classList.add('hidden');
                getHostHistoryBtn.classList.remove('hidden');
            } else {
                // å€‹åˆ¥ã‚¢ã‚¤ãƒ†ãƒ é¸æŠãƒ¢ãƒ¼ãƒ‰
                hostSelectInfo.textContent = '1ã¤ã®ãƒ›ã‚¹ãƒˆã‚’æ¤œç´¢ã—ã¦é¸æŠã—ã¦ãã ã•ã„ã€‚';
                
                // è¤‡æ•°ãƒ›ã‚¹ãƒˆãŒé¸æŠã•ã‚Œã¦ã„ã‚‹å ´åˆã¯è­¦å‘Š
                if (selectedHosts.length > 1) {
                    showStatus('hostStatus', 'å€‹åˆ¥ã‚¢ã‚¤ãƒ†ãƒ ãƒ¢ãƒ¼ãƒ‰ã§ã¯1ã¤ã®ãƒ›ã‚¹ãƒˆã®ã¿é¸æŠã—ã¦ãã ã•ã„', 'error');
                    // 2ã¤ç›®ä»¥é™ã®ãƒ›ã‚¹ãƒˆã‚’å‰Šé™¤
                    while (selectedHosts.length > 1) {
                        selectedHosts.pop();
                    }
                    updateSelectedHostsDisplay();
                }
                
                // ãƒ›ã‚¹ãƒˆãŒé¸æŠã•ã‚Œã¦ã„ã‚‹å ´åˆã¯ã‚¢ã‚¤ãƒ†ãƒ ã‚’ãƒ­ãƒ¼ãƒ‰
                if (selectedHosts.length === 1) {
                    loadItems();
                } else {
                    itemSection.classList.add('hidden');
                }
                
                timeSection.classList.add('hidden');
                getHistoryBtn.classList.remove('hidden');
                getHostHistoryBtn.classList.add('hidden');
            }
        }

        async function getHostHistory() {
            if (selectedHosts.length === 0) {
                showStatus('timeStatus', 'ãƒ›ã‚¹ãƒˆã‚’é¸æŠã—ã¦ãã ã•ã„', 'error');
                return;
            }

            const timeFrom = document.getElementById('timeFrom').value;
            const timeTill = document.getElementById('timeTill').value;

            if (!timeFrom || !timeTill) {
                showStatus('timeStatus', 'æ™‚é–“ç¯„å›²ã‚’æŒ‡å®šã—ã¦ãã ã•ã„', 'error');
                return;
            }

            const timeFromUnix = Math.floor(new Date(timeFrom).getTime() / 1000);
            const timeTillUnix = Math.floor(new Date(timeTill).getTime() / 1000);

            if (timeFromUnix >= timeTillUnix) {
                showStatus('timeStatus', 'é–‹å§‹æ™‚åˆ»ã¯çµ‚äº†æ™‚åˆ»ã‚ˆã‚Šå‰ã§ã‚ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™', 'error');
                return;
            }

            showStatus('timeStatus', `ãƒ›ã‚¹ãƒˆã‚’é¸æŠ: ${selectedHosts.length}ãƒ›ã‚¹ãƒˆ...`, 'info');
            historyData = [];

            try {
                // é¸æŠã•ã‚ŒãŸãƒ›ã‚¹ãƒˆã®ã™ã¹ã¦ã®ã‚¢ã‚¤ãƒ†ãƒ ã‚’å–å¾—
                const selectedHostIds = selectedHosts.map(h => h.hostid);
                
                // ãƒ›ã‚¹ãƒˆIDã¨åå‰ã®ãƒãƒƒãƒ—ã‚’ä½œæˆï¼ˆãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æ”¹å–„ï¼‰
                const hostNameMap = new Map();
                selectedHosts.forEach(h => {
                    hostNameMap.set(h.hostid, h.name);
                });
                
                let processedHosts = 0;
                for (const hostId of selectedHostIds) {
                    processedHosts++;
                    const hostName = hostNameMap.get(hostId);
                    
                    showStatus('timeStatus', `ãƒ›ã‚¹ãƒˆ ${hostName} ã®ã‚¢ã‚¤ãƒ†ãƒ ã‚’å–å¾—ä¸­ (${processedHosts}/${selectedHostIds.length})...`, 'info');
                    
                    // ãƒ›ã‚¹ãƒˆã®ã‚¢ã‚¤ãƒ†ãƒ ã‚’å–å¾—
                    const items = await callZabbixAPI('item.get', {
                        output: ['itemid', 'name', 'key_', 'value_type'],
                        hostids: hostId,
                        sortfield: 'name',
                        webitems: false
                    });

                    showStatus('timeStatus', `ãƒ›ã‚¹ãƒˆ ${hostName}: ${items.length}å€‹ã®ã‚¢ã‚¤ãƒ†ãƒ ã®ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ä¸­...`, 'info');

                    // å„ã‚¢ã‚¤ãƒ†ãƒ ã®å±¥æ­´ãƒ‡ãƒ¼ã‚¿ã‚’é †æ¬¡å–å¾—ï¼ˆé€²æ—è¡¨ç¤ºã®ãŸã‚ï¼‰
                    for (let i = 0; i < items.length; i++) {
                        const item = items[i];
                        
                        showStatus('timeStatus', 
                            `ãƒ›ã‚¹ãƒˆ ${hostName}: ${item.name} ã®ãƒ‡ãƒ¼ã‚¿å–å¾—ä¸­ (${i + 1}/${items.length})...`, 
                            'info');
                        
                        const history = await callZabbixAPI('history.get', {
                            output: 'extend',
                            history: parseInt(item.value_type),
                            itemids: item.itemid,
                            sortfield: 'clock',
                            sortorder: 'ASC',
                            time_from: timeFromUnix,
                            time_till: timeTillUnix
                        });
                        
                        history.forEach(record => {
                            historyData.push({
                                hostName: hostName,
                                itemId: item.itemid,
                                itemName: item.name,
                                itemKey: item.key_,
                                clock: record.clock,
                                timestamp: new Date(record.clock * 1000).toLocaleString('ja-JP', {
                                    year: 'numeric',
                                    month: '2-digit',
                                    day: '2-digit',
                                    hour: '2-digit',
                                    minute: '2-digit',
                                    second: '2-digit',
                                    hour12: false
                                }),
                                value: record.value,
                                ns: record.ns
                            });
                        });
                    }
                }

                showStatus('timeStatus', `${historyData.length}ä»¶ã®å±¥æ­´ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ã—ã¾ã—ãŸã€‚CSVã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆãƒœã‚¿ãƒ³ã‹ã‚‰ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã—ã¦ãã ã•ã„ã€‚`, 'success');
                // ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹å‘ä¸Šã®ãŸã‚ã€ãƒ‡ãƒ¼ã‚¿ã‚’ç”»é¢ã«è¡¨ç¤ºã—ã¾ã›ã‚“
                // displayResults();
                
                // çµæœã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‚’è¡¨ç¤ºï¼ˆã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆãƒœã‚¿ãƒ³ã®ãŸã‚ï¼‰
                document.getElementById('resultsSection').classList.remove('hidden');
                showStatus('resultsStatus', `${historyData.length}ä»¶ã®ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ã—ã¾ã—ãŸã€‚è¡¨ç¤ºã¯ã‚¹ã‚­ãƒƒãƒ—ã•ã‚Œã¦ã„ã¾ã™ï¼ˆãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹å‘ä¸Šã®ãŸã‚ï¼‰ã€‚CSVã¾ãŸã¯JSONã§ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã—ã¦ãã ã•ã„ã€‚`, 'info');

            } catch (error) {
                showStatus('timeStatus', `å±¥æ­´ãƒ‡ãƒ¼ã‚¿å–å¾—ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
            }
        }


        async function getHistory() {
            const itemSelect = document.getElementById('itemSelect');
            const selectedOptions = Array.from(itemSelect.selectedOptions);

            if (selectedOptions.length === 0) {
                showStatus('timeStatus', 'ã‚¢ã‚¤ãƒ†ãƒ ã‚’é¸æŠã—ã¦ãã ã•ã„', 'error');
                return;
            }

            const timeFrom = document.getElementById('timeFrom').value;
            const timeTill = document.getElementById('timeTill').value;

            if (!timeFrom || !timeTill) {
                showStatus('timeStatus', 'æ™‚é–“ç¯„å›²ã‚’æŒ‡å®šã—ã¦ãã ã•ã„', 'error');
                return;
            }

            const timeFromUnix = Math.floor(new Date(timeFrom).getTime() / 1000);
            const timeTillUnix = Math.floor(new Date(timeTill).getTime() / 1000);

            if (timeFromUnix >= timeTillUnix) {
                showStatus('timeStatus', 'é–‹å§‹æ™‚åˆ»ã¯çµ‚äº†æ™‚åˆ»ã‚ˆã‚Šå‰ã§ã‚ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™', 'error');
                return;
            }

            showStatus('timeStatus', `ãƒ‡ãƒ¼ã‚¿å–å¾—ã‚’é–‹å§‹ã—ã¾ã™ï¼ˆ${selectedOptions.length}ã‚¢ã‚¤ãƒ†ãƒ ï¼‰...`, 'info');
            historyData = [];

            try {
                // é¸æŠã•ã‚ŒãŸãƒ›ã‚¹ãƒˆåã‚’å–å¾—
                const hostSelect = document.getElementById('hostSelect');
                const selectedHostOption = hostSelect.options[hostSelect.selectedIndex];
                const hostName = selectedHostOption ? selectedHostOption.textContent : '';

                for (let i = 0; i < selectedOptions.length; i++) {
                    const option = selectedOptions[i];
                    const itemId = option.value;
                    const valueType = option.dataset.valueType;
                    const itemName = option.textContent;

                    showStatus('timeStatus', `ãƒ‡ãƒ¼ã‚¿å–å¾—ä¸­: ${itemName} (${i + 1}/${selectedOptions.length})...`, 'info');

                    const history = await callZabbixAPI('history.get', {
                        output: 'extend',
                        history: parseInt(valueType),
                        itemids: itemId,
                        sortfield: 'clock',
                        sortorder: 'ASC',
                        time_from: timeFromUnix,
                        time_till: timeTillUnix
                    });

                    history.forEach(record => {
                        historyData.push({
                            hostName: hostName,
                            itemId: itemId,
                            itemName: itemName,
                            clock: record.clock,
                            timestamp: new Date(record.clock * 1000).toLocaleString('ja-JP', {
                                year: 'numeric',
                                month: '2-digit',
                                day: '2-digit',
                                hour: '2-digit',
                                minute: '2-digit',
                                second: '2-digit',
                                hour12: false
                            }),
                            value: record.value,
                            ns: record.ns
                        });
                    });
                }

                showStatus('timeStatus', `${historyData.length}ä»¶ã®å±¥æ­´ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ã—ã¾ã—ãŸã€‚CSVã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆãƒœã‚¿ãƒ³ã‹ã‚‰ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã—ã¦ãã ã•ã„ã€‚`, 'success');
                // ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹å‘ä¸Šã®ãŸã‚ã€ãƒ‡ãƒ¼ã‚¿ã‚’ç”»é¢ã«è¡¨ç¤ºã—ã¾ã›ã‚“
                // displayResults();
                
                // çµæœã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‚’è¡¨ç¤ºï¼ˆã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆãƒœã‚¿ãƒ³ã®ãŸã‚ï¼‰
                document.getElementById('resultsSection').classList.remove('hidden');
                showStatus('resultsStatus', `${historyData.length}ä»¶ã®ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ã—ã¾ã—ãŸã€‚è¡¨ç¤ºã¯ã‚¹ã‚­ãƒƒãƒ—ã•ã‚Œã¦ã„ã¾ã™ï¼ˆãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹å‘ä¸Šã®ãŸã‚ï¼‰ã€‚CSVã¾ãŸã¯JSONã§ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã—ã¦ãã ã•ã„ã€‚`, 'info');

            } catch (error) {
                showStatus('timeStatus', `å±¥æ­´ãƒ‡ãƒ¼ã‚¿å–å¾—ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
            }
        }

        function displayResults() {
            const resultsSection = document.getElementById('resultsSection');
            const resultsTable = document.getElementById('resultsTable');

            if (historyData.length === 0) {
                resultsTable.innerHTML = '<p class="info-text">ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“</p>';
                resultsSection.classList.remove('hidden');
                return;
            }

            let tableHTML = '<table><thead><tr>';
            // ãƒ›ã‚¹ãƒˆå…¨ä½“ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã®å ´åˆã¯ãƒ›ã‚¹ãƒˆåã¨ã‚¢ã‚¤ãƒ†ãƒ ã‚­ãƒ¼ã‚‚è¡¨ç¤º
            if (exportMode === 'host') {
                tableHTML += '<th>ãƒ›ã‚¹ãƒˆ</th>';
                tableHTML += '<th>ã‚¢ã‚¤ãƒ†ãƒ </th>';
                tableHTML += '<th>ã‚­ãƒ¼</th>';
                tableHTML += '<th>ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—</th>';
                tableHTML += '<th>å€¤</th>';
            } else {
                tableHTML += '<th>ãƒ›ã‚¹ãƒˆ</th>';
                tableHTML += '<th>ã‚¢ã‚¤ãƒ†ãƒ </th>';
                tableHTML += '<th>ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—</th>';
                tableHTML += '<th>å€¤</th>';
            }
            tableHTML += '</tr></thead><tbody>';

            historyData.forEach(record => {
                tableHTML += '<tr>';
                if (exportMode === 'host') {
                    tableHTML += `<td>${escapeHtml(record.hostName || '')}</td>`;
                    tableHTML += `<td>${escapeHtml(record.itemName)}</td>`;
                    tableHTML += `<td>${escapeHtml(record.itemKey || '')}</td>`;
                    tableHTML += `<td>${escapeHtml(record.timestamp)}</td>`;
                    tableHTML += `<td>${escapeHtml(record.value)}</td>`;
                } else {
                    tableHTML += `<td>${escapeHtml(record.hostName || '')}</td>`;
                    tableHTML += `<td>${escapeHtml(record.itemName)}</td>`;
                    tableHTML += `<td>${escapeHtml(record.timestamp)}</td>`;
                    tableHTML += `<td>${escapeHtml(record.value)}</td>`;
                }
                tableHTML += '</tr>';
            });

            tableHTML += '</tbody></table>';
            resultsTable.innerHTML = tableHTML;
            resultsSection.classList.remove('hidden');
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = String(text || '');
            return div.innerHTML;
        }

        async function exportToCSV() {
            if (historyData.length === 0) {
                showStatus('resultsStatus', 'ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã™ã‚‹ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“', 'error');
                return;
            }

            // CompressionStream APIã®ã‚µãƒãƒ¼ãƒˆãƒã‚§ãƒƒã‚¯
            if (!('CompressionStream' in window)) {
                showStatus('resultsStatus', 'ã‚¨ãƒ©ãƒ¼: ãŠä½¿ã„ã®ãƒ–ãƒ©ã‚¦ã‚¶ã¯CompressionStream APIã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã¾ã›ã‚“ã€‚Chrome 80+, Edge 80+, Safari 16.4+ãŒå¿…è¦ã§ã™ã€‚', 'error');
                console.error('CompressionStream API is not supported');
                return;
            }

            showStatus('resultsStatus', 'CSVãƒ•ã‚¡ã‚¤ãƒ«ã‚’ç”Ÿæˆä¸­...', 'info');

            try {
                // ã‚¢ã‚¤ãƒ†ãƒ ã”ã¨ã«ãƒ‡ãƒ¼ã‚¿ã‚’ã‚°ãƒ«ãƒ¼ãƒ—åŒ–
                const itemGroups = {};
                historyData.forEach(record => {
                    const itemKey = `${record.itemId}_${record.itemName}`;
                    if (!itemGroups[itemKey]) {
                        itemGroups[itemKey] = {
                            itemName: record.itemName,
                            itemKey: record.itemKey,
                            hostName: record.hostName,
                            data: []
                        };
                    }
                    itemGroups[itemKey].data.push(record);
                });

                const itemCount = Object.keys(itemGroups).length;

                // ZIPãƒ•ã‚¡ã‚¤ãƒ«ã‚’ç”Ÿæˆï¼ˆãƒã‚¤ãƒ†ã‚£ãƒ–APIä½¿ç”¨ï¼‰
                showStatus('resultsStatus', 'ZIPãƒ•ã‚¡ã‚¤ãƒ«ã‚’ç”Ÿæˆä¸­...', 'info');
                const zipBlob = await createZipFile(itemGroups);

                // ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ã‚’å«ã‚€ãƒ•ã‚¡ã‚¤ãƒ«åã‚’ç”Ÿæˆ
                const now = new Date();
                const timestamp = now.toISOString().replace(/[-:]/g, '').replace('T', '-').split('.')[0];
                const zipFilename = `zabbix-history-export-${timestamp}.zip`;

                // ZIPãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰
                downloadFile(zipBlob, zipFilename, 'application/zip');
                showStatus('resultsStatus', `${itemCount}å€‹ã®CSVãƒ•ã‚¡ã‚¤ãƒ«ã‚’ZIPã«ã¾ã¨ã‚ã¦ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã—ã¾ã—ãŸ`, 'success');
            } catch (error) {
                showStatus('resultsStatus', `ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
                console.error('Export error:', error);
            }
        }

        // CompressionStream APIã‚’ä½¿ç”¨ã—ã¦ZIPãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä½œæˆ
        async function createZipFile(itemGroups) {
            const encoder = new TextEncoder();
            const files = [];
            
            // å„CSVãƒ•ã‚¡ã‚¤ãƒ«ã®å†…å®¹ã¨ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’æº–å‚™
            Object.entries(itemGroups).forEach(([key, group]) => {
                let csv = '\uFEFF'; // UTF-8 BOM for Excel compatibility with Japanese characters
                
                // ãƒ˜ãƒƒãƒ€ãƒ¼è¡Œ
                if (exportMode === 'host') {
                    csv += 'ã‚¢ã‚¤ãƒ†ãƒ ,ã‚­ãƒ¼,ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—,å€¤\n';
                } else {
                    csv += 'ã‚¢ã‚¤ãƒ†ãƒ ,ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—,å€¤\n';
                }

                group.data.forEach(record => {
                    if (exportMode === 'host') {
                        csv += `"${record.itemName}","${record.itemKey || ''}","${record.timestamp}","${record.value}"\n`;
                    } else {
                        csv += `"${record.itemName}","${record.timestamp}","${record.value}"\n`;
                    }
                });

                // ãƒ•ã‚¡ã‚¤ãƒ«åã‚’ç”Ÿæˆ: {ãƒ›ã‚¹ãƒˆå}_{ã‚¢ã‚¤ãƒ†ãƒ å}_{é–‹å§‹æ—¥æ™‚}-{çµ‚äº†æ—¥æ™‚}.csv
                const safeHostName = (group.hostName || 'unknown').replace(/[^a-zA-Z0-9\u3040-\u309F\u30A0-\u30FF\u4E00-\u9FAF]/g, '_');
                const safeItemName = group.itemName.replace(/[^a-zA-Z0-9\u3040-\u309F\u30A0-\u30FF\u4E00-\u9FAF]/g, '_');
                
                // ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰é–‹å§‹æ—¥æ™‚ã¨çµ‚äº†æ—¥æ™‚ã‚’å–å¾—
                let startTime = 'unknown';
                let endTime = 'unknown';
                if (group.data.length > 0) {
                    const timestamps = group.data.map(d => d.clock);
                    const minTimestamp = Math.min(...timestamps);
                    const maxTimestamp = Math.max(...timestamps);
                    
                    // YYYYMMDDHHMMSSå½¢å¼ã«ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ
                    const formatDateTime = (timestamp) => {
                        const date = new Date(timestamp * 1000);
                        const year = date.getFullYear();
                        const month = String(date.getMonth() + 1).padStart(2, '0');
                        const day = String(date.getDate()).padStart(2, '0');
                        const hours = String(date.getHours()).padStart(2, '0');
                        const minutes = String(date.getMinutes()).padStart(2, '0');
                        const seconds = String(date.getSeconds()).padStart(2, '0');
                        return `${year}${month}${day}${hours}${minutes}${seconds}`;
                    };
                    
                    startTime = formatDateTime(minTimestamp);
                    endTime = formatDateTime(maxTimestamp);
                }
                
                const filename = `${safeHostName}_${safeItemName}_${startTime}-${endTime}.csv`;

                files.push({
                    name: filename,
                    content: encoder.encode(csv)
                });
            });

            // ZIPå½¢å¼ã§ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸åŒ–
            return await generateZip(files);
        }

        // ZIPå½¢å¼ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ç”Ÿæˆï¼ˆCompressionStreamä½¿ç”¨ï¼‰
        async function generateZip(files) {
            const zipParts = [];
            const centralDirectory = [];
            let offset = 0;

            // å„ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ZIPã«è¿½åŠ 
            for (const file of files) {
                const filename = new TextEncoder().encode(file.name);
                const content = file.content;
                const crc32 = calculateCRC32(content);
                const modTime = dosDateTime(new Date());

                // åœ§ç¸®
                const compressed = await compressData(content);

                // Local file header
                const localHeader = new Uint8Array(30 + filename.length);
                const view = new DataView(localHeader.buffer);
                
                view.setUint32(0, 0x04034b50, true); // Local file header signature
                view.setUint16(4, 20, true); // Version needed to extract (2.0)
                view.setUint16(6, 0, true); // General purpose bit flag
                view.setUint16(8, 8, true); // Compression method (8 = deflate)
                view.setUint16(10, modTime & 0xFFFF, true); // File last mod time
                view.setUint16(12, (modTime >> 16) & 0xFFFF, true); // File last mod date
                view.setUint32(14, crc32, true); // CRC-32
                view.setUint32(18, compressed.length, true); // Compressed size
                view.setUint32(22, content.length, true); // Uncompressed size
                view.setUint16(26, filename.length, true); // Filename length
                view.setUint16(28, 0, true); // Extra field length
                localHeader.set(filename, 30);

                zipParts.push(localHeader);
                zipParts.push(compressed);

                // Central directory entry
                centralDirectory.push({
                    filename: filename,
                    crc32: crc32,
                    compressedSize: compressed.length,
                    uncompressedSize: content.length,
                    offset: offset,
                    modTime: modTime
                });

                offset += localHeader.length + compressed.length;
            }

            // Central directory
            const centralDirParts = [];
            for (const entry of centralDirectory) {
                const cdHeader = new Uint8Array(46 + entry.filename.length);
                const view = new DataView(cdHeader.buffer);
                
                view.setUint32(0, 0x02014b50, true); // Central directory file header signature
                view.setUint16(4, 0x033F, true); // Version made by (3.0, Unix)
                view.setUint16(6, 20, true); // Version needed to extract
                view.setUint16(8, 0, true); // General purpose bit flag
                view.setUint16(10, 8, true); // Compression method
                view.setUint16(12, entry.modTime & 0xFFFF, true); // File last mod time
                view.setUint16(14, (entry.modTime >> 16) & 0xFFFF, true); // File last mod date
                view.setUint32(16, entry.crc32, true); // CRC-32
                view.setUint32(20, entry.compressedSize, true); // Compressed size
                view.setUint32(24, entry.uncompressedSize, true); // Uncompressed size
                view.setUint16(28, entry.filename.length, true); // Filename length
                view.setUint16(30, 0, true); // Extra field length
                view.setUint16(32, 0, true); // File comment length
                view.setUint16(34, 0, true); // Disk number start
                view.setUint16(36, 1, true); // Internal file attributes (text file)
                view.setUint32(38, 0x81A40000, true); // External file attributes (Unix permissions 0644)
                view.setUint32(42, entry.offset, true); // Relative offset of local header
                cdHeader.set(entry.filename, 46);
                
                centralDirParts.push(cdHeader);
            }

            const centralDirData = new Uint8Array(centralDirParts.reduce((sum, part) => sum + part.length, 0));
            let cdOffset = 0;
            for (const part of centralDirParts) {
                centralDirData.set(part, cdOffset);
                cdOffset += part.length;
            }

            // End of central directory record
            const eocd = new Uint8Array(22);
            const eocdView = new DataView(eocd.buffer);
            eocdView.setUint32(0, 0x06054b50, true); // End of central dir signature
            eocdView.setUint16(4, 0, true); // Number of this disk
            eocdView.setUint16(6, 0, true); // Disk where central directory starts
            eocdView.setUint16(8, files.length, true); // Number of central directory records on this disk
            eocdView.setUint16(10, files.length, true); // Total number of central directory records
            eocdView.setUint32(12, centralDirData.length, true); // Size of central directory
            eocdView.setUint32(16, offset, true); // Offset of start of central directory
            eocdView.setUint16(20, 0, true); // Comment length

            // ã™ã¹ã¦ã®ãƒ‘ãƒ¼ãƒ„ã‚’çµåˆ
            return new Blob([...zipParts, centralDirData, eocd], { type: 'application/zip' });
        }

        // CompressionStreamã‚’ä½¿ç”¨ã—ã¦ãƒ‡ãƒ¼ã‚¿ã‚’åœ§ç¸®
        async function compressData(data) {
            const stream = new Blob([data]).stream();
            const compressedStream = stream.pipeThrough(new CompressionStream('deflate-raw'));
            const blob = await new Response(compressedStream).blob();
            return new Uint8Array(await blob.arrayBuffer());
        }

        // CRC32ãƒã‚§ãƒƒã‚¯ã‚µãƒ ã‚’è¨ˆç®—
        function calculateCRC32(data) {
            const crcTable = [];
            for (let i = 0; i < 256; i++) {
                let c = i;
                for (let j = 0; j < 8; j++) {
                    c = (c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1);
                }
                crcTable[i] = c;
            }

            let crc = 0xFFFFFFFF;
            for (let i = 0; i < data.length; i++) {
                crc = crcTable[(crc ^ data[i]) & 0xFF] ^ (crc >>> 8);
            }
            return (crc ^ 0xFFFFFFFF) >>> 0;
        }

        // DOSæ—¥æ™‚å½¢å¼ã«å¤‰æ›
        function dosDateTime(date) {
            const year = date.getFullYear();
            const month = date.getMonth() + 1;
            const day = date.getDate();
            const hours = date.getHours();
            const minutes = date.getMinutes();
            const seconds = Math.floor(date.getSeconds() / 2);

            const dosDate = ((year - 1980) << 9) | (month << 5) | day;
            const dosTime = (hours << 11) | (minutes << 5) | seconds;

            return (dosDate << 16) | dosTime;
        }

        function exportToJSON() {
            if (historyData.length === 0) {
                showStatus('resultsStatus', 'ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã™ã‚‹ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“', 'error');
                return;
            }

            const json = JSON.stringify(historyData, null, 2);
            downloadFile(json, 'zabbix-history-export.json', 'application/json');
            showStatus('resultsStatus', 'JSONãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã—ã¾ã—ãŸ', 'success');
        }

        function downloadFile(content, filename, mimeType) {
            // contentãŒæ—¢ã«Blobã®å ´åˆã¯ãã®ã¾ã¾ä½¿ç”¨ã€ãã†ã§ãªã‘ã‚Œã°Blobã‚’ä½œæˆ
            const blob = content instanceof Blob ? content : new Blob([content], { type: mimeType });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = filename;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
        }
    </script>
</body>
</html>
